from math import sqrt
from functools import reduce
from copy import deepcopy
import json

GRAVITY_CONST = 6.67e-11

DIM_SIZE = 2

class Vector(list):
	def __init__(self):
		self.extend([0]*DIM_SIZE)

	def length(self):
		return sqrt(self.length2())

	def length2(self):
		return reduce(lambda a,b : a + b*b, self, 0)

	def scale(self, scalar):
		for i in range(len(self)):
			self[i] *= scalar
		return self

	def const_scale(self, scalar):
		return [e*scalar for e in self]

	def add(self, v):
		for i in range(len(self)):
			self[i] += v[i]
		return self

	def sub(self, v):
		for i in range(len(self)):
			self[i] -= v[i]
		return self

	def __repr__(self):
		return f'[{", ".join(map(lambda a: f"{a:.2e}", self))}]'

class Body:
	def __init__(self, p, v):
		self.p = deepcopy(p)
		self.v = deepcopy(v)
		self.zeroGravityForce()

	def zeroGravityForce(self):
		self.F = Vector()

	def __repr__(self):
		return f"p{self.p}, v{self.v}, F{self.F}"

class SpaceObject(Body):
	def __init__(self, m, r, p=Vector(), v=Vector()):
		self.mass = m
		self.radius = r
		return super().__init__(p, v)

	def pull(self, so: 'SpaceObject'):
		# calculate G force between self and so - F = G/r^2 = (r-> / |r|) * G/r^2 = r-> * [G/(r^2*r)]
		# p1 = vector(so -> self)	self 1,1 so 0,0 => p1 1,1
		p1 = deepcopy(self.p)
		p1.sub(so.p)
		r2 = p1.length2()
		r = sqrt(r2)
		# detect collisions
		if r > self.radius+so.radius:
			r2 = GRAVITY_CONST/(r2*r)	# div by sqrt(r2) to normalize p1
			p1.scale(r2)

			# apply to both, but in different direction, because p1 direction - vector(so -> self)
			for i in range(DIM_SIZE):
				so.F[i]   += p1[i]*self.mass
				self.F[i] -= p1[i]*so.mass
		else:
			raise Exception("Collision!")
			#pass # TODO - what about collision

	def move(self, dt):
		# apply force calculated in F
		self.v.add(self.F.scale(dt))
		# apply new velocity to position
		self.p.add(self.v.const_scale(dt))

	def __repr__(self):
		return f"M{self.mass}, R{self.radius}, {super().__repr__()}"

class Engine:
	def __init__(self, mass_empty, thrust, consumption):
		self.mass = mass_empty
		self.thrust = thrust				# N
		self.consumption = consumption		# kg/s - thrust / Isp / g0

	def __repr__(self):
		return f"Thrust{self.thrust}, M{self.mass}, Consump{self.consumption}, {super().__repr__()}"

	# returns Force, fuel_left
	def fire(self, engine_force, fuel_tank, dt, throttle=1.0):
		fuel = self.consumption*dt*throttle
		if fuel > fuel_tank:
			throttle *= fuel_tank / fuel	# % of time the fuel is used
			return engine_force + self.thrust * throttle, 0
		else:
			# self.mass_fuel_avg = self.mass_fuel_left + fuel/2
			return engine_force + self.thrust * throttle, fuel_tank - fuel

class Merlin1D(Engine):
	def __init__(self, count = 1):
		super().__init__(470*count, 854000*count, (854000/311/9.81)*count) # mass flow rate - kg/s - thrust / Isp / g0  -> 279.9164

class SpaceShip(SpaceObject):
	def __init__(self, mass, radius, fuel, p=Vector(), v=Vector()):
		self.mass_self = mass
		self.fuel = fuel
		self.direction = Vector()
		self.direction[0] = 1	# keep it normalized
		self.engines = []
		return super().__init__(mass, radius, p, v)

	def addEngine(self, e: Engine):
		self.engines.append(e)
		self.mass += e.mass

	def fire(self, dt, throttle=1.0):
		if self.fuel <= 0: return
		# add force generated by engines to gravitational pull
		engine_force = 0
		for engine in self.engines:
			# apply every engine thrust in the same direction
			engine_force, self.fuel = engine.fire(engine_force, self.fuel, dt, throttle)
		# apply every engine thrust in direction
		self.F.add(self.direction.const_scale(engine_force/self.mass))

	def move(self, dt, throttle=1.0):
		# fire engines
		self.fire(dt, throttle)
		# apply the force
		super().move(dt)
		# apply burned fuel
		self.mass = self.mass_self
		for engine in self.engines:
			self.mass += engine.mass
		self.mass += self.fuel

def step(spaceObjects, dt):
	# 1. For all - zero gravity pull
	[so.zeroGravityForce() for so in spaceObjects]
	# 2. For all - pull - make sure to not do it twice
	for right, so_right in enumerate(spaceObjects[1:], 1):
		for left in range(right):
			so_right.pull(spaceObjects[left])
	# 3. For all - move objects (it will fire engines too)
	[so.move(dt) for so in spaceObjects]
	# TODO 4. what about collisions

def stepThrust(spaceObjects, dt, thrust):
	# 1. For all - zero gravity pull
	[so.zeroGravityForce() for so in spaceObjects]
	# 2. For all - pull - make sure to not do it twice
	for right, so_right in enumerate(spaceObjects[1:], 1):
		for left in range(right):
			so_right.pull(spaceObjects[left])
	# 3. For all - move objects (it will fire engines too)
	for so in spaceObjects:
		if isinstance(so, SpaceShip):
			so.move(dt, thrust)
			continue
		so.move(dt)

def move(spacePositions, spaceObjects, dt, stepsCount):
	for i in range(stepsCount):
		spacePositions.append([{"p": deepcopy(s.p), "v": deepcopy(s.v)} for s in spaceObjects])
		step(spaceObjects, dt)

def moveThrust(spacePositions, spaceObjects, dt, thrustLevels):
	for i in range(len(thrustLevels)):
		spacePositions.append([{"p": deepcopy(s.p), "v": deepcopy(s.v), "f": s.fuel if isinstance(s, SpaceShip) else 0 } for s in spaceObjects])
		stepThrust(spaceObjects, dt, thrustLevels[i])

def moveFuel(spacePositions, spaceObjects, dt, thrustLevels):
	for i in range(60*10):
		spacePositions.append([{"p": deepcopy(s.p), "v": deepcopy(s.v), "f": s.fuel if isinstance(s, SpaceShip) else 0 } for s in spaceObjects])
		k = thrustLevels.count(i)
		stepThrust(spaceObjects, dt, k/5)

def testFlight(genom):
	earth = SpaceObject(EARTHMASS, EARTHRADIUS)
	earth.p[0] = 0#AU
	earth.v[1] = 0#sqrt(GRAVITY_CONST*SUNMASS / AU)
	earth.v[0] = 0#earth.v[1]/3

	falcon9 = SpaceShip(63.8e3, 70, 1420e3-63.8e3)
	#falcon9.addEngine(Merlin1D())
	falcon9.p[0] = EARTHRADIUS
	falcon9.v[1] = sqrt(GRAVITY_CONST*EARTHMASS / falcon9.p[0])

	falconLander = deepcopy(falcon9)
	falconLander.addEngine(Merlin1D(9))
	falconLander.fuel /= 10 # 10%
	falconLander.p[0] = 0
	falconLander.p[1] = EARTHRADIUS + 100000 + 20000 # height, over 100km
	falconLander.v[0] = 0
	falconLander.v[1] = 0
	falconLander.direction[0] = 0	# keep it normalized
	falconLander.direction[1] = 1	# keep it normalized

	spaceObjects = [earth, falconLander] #falcon93, falcon92]#, falcon9]#, moon]#, earth2]
	dt = 1 #24h into seconds
	spacePositions = []
	stepsCount = 60*20
	thrustTab = genom
	try:
		#move(spacePositions, spaceObjects, dt, stepsCount)
		#moveThrust(spacePositions, spaceObjects, dt, thrustTab)
		moveFuel(spacePositions, spaceObjects, dt, genom)
	except Exception as e:
		#print(e)
		#print(f"Final velocity: {spaceObjects[1].v}")
		pass
	return spacePositions[-1][1]['p'], spacePositions[-1][1]['v']


SUNMASS = 1.9884e30
EARTHMASS = 5.972e24
SUNRADIUS = 696340000
EARTHRADIUS = 6370000
AU = 1.496e11

MOONMASS = 7.34767309e22
MOONRADIUS = 1737.4e3
MOONPERIGEE = 362600e3


import matplotlib.pyplot as plt
import numpy as np

import matplotlib.animation as ani
import random

def buildPlot(i=int):
	global x
	global y
	global ax
	p = ax[0].plot(x[:i], y[:i])
	p[0].set_color('red')

def buildPlot2(i=int):
	global x
	global f
	global ax
	p = ax[1].plot(x[:i], f[:i])
	p[0].set_color('green')

def buildPlot3(i=int):
	global x
	global vv
	global vv1
	global vv2
	global vv3
	global vv4
	global ax
	p = ax[2].plot(x[:i], vv[:i])
	p[0].set_color('blue')

if __name__ == "__main__":
	#Å›sun = SpaceObject(SUNMASS, SUNRADIUS)
	earth = SpaceObject(EARTHMASS, EARTHRADIUS)
	earth.p[0] = 0#AU
	earth.v[1] = 0#sqrt(GRAVITY_CONST*SUNMASS / AU)
	earth.v[0] = 0#earth.v[1]/3

	earth2 = SpaceObject(EARTHMASS, EARTHRADIUS)
	earth2.p[0] = -AU
	earth2.v[1] = sqrt(GRAVITY_CONST*SUNMASS / AU)/2
	earth2.v[0] = earth.v[1]/4

	moon = SpaceObject(MOONMASS, MOONRADIUS)
	moon.p[0] = earth.p[0] + MOONPERIGEE
	moon.v[1] = sqrt(GRAVITY_CONST*EARTHMASS / MOONPERIGEE)
	earth.v[1] = 0#-sqrt(GRAVITY_CONST*MOONMASS / MOONPERIGEE)/9.012

	falcon9 = SpaceShip(63.8e3, 70, 1420e3-63.8e3)
	#falcon9.addEngine(Merlin1D())
	falcon9.p[0] = EARTHRADIUS
	falcon9.v[1] = sqrt(GRAVITY_CONST*EARTHMASS / falcon9.p[0])

	falcon92 = deepcopy(falcon9)
	falcon92.addEngine(Merlin1D())
	falcon92.p[0] += 1e7
	falcon92.v[1] = 0
	falcon92.direction[0] = 0#-sqrt(2)/2	# keep it normalized
	falcon92.direction[1] = 1#sqrt(2)/2	# keep it normalized

	falcon93 = deepcopy(falcon92)
	falcon93.fuel /= 9
	falcon93.p[0] +=1e7
	falcon93.direction[0] = 0	# keep it normalized
	falcon93.direction[1] = 1	# keep it normalized

	falconLander = deepcopy(falcon9)
	falconLander.addEngine(Merlin1D(9))
	falconLander.fuel /= 10 # 10%  -> 135620
	falconLander.p[0] = 0
	falconLander.p[1] = EARTHRADIUS + 100000 + 20000 # height, over 100km
	falconLander.v[0] = 1
	falconLander.v[1] = 0
	falconLander.direction[0] = 0	# keep it normalized
	falconLander.direction[1] = 1	# keep it normalized

	print(falconLander.fuel)

	spaceObjects = [earth, falconLander] #falcon93, falcon92]#, falcon9]#, moon]#, earth2]
	spaceObjects1 = deepcopy(spaceObjects)
	spaceObjects2 = deepcopy(spaceObjects)
	spaceObjects3 = deepcopy(spaceObjects)
	spaceObjects4 = deepcopy(spaceObjects)
	dt = 1 #24h into seconds
	spacePositions = []
	spacePositions1 = []
	spacePositions2 = []
	spacePositions3 = []
	spacePositions4 = []
	stepsCount = 60*20
	#thrustTab = [0 + 0.0/120*i for i in range(120)]
	#thrustTab += [float(1) for i in range(stepsCount - 120)]
	"""
	with open('best_score-per_gen_2.json') as f:
		data = json.load(f)
	thrustTab = data[-1]['brake']
	#thrustTab = [i%600 for i in range(484*5)]
	#thrustTab1 = data[1]['brake']
	#thrustTab2 = data[250]['brake']
	#thrustTab3 = data[500]['brake']
	#thrustTab4 = data[750]['brake']
	print(thrustTab)
	fig, ax = plt.subplots(1,3, figsize=(18,6))
	ax[0].set_ylim([EARTHRADIUS, 6.5e6])
	ax[0].set_title("y(t) - position")
	ax[1].set_ylim([0, falconLander.fuel*1.01])
	ax[1].set_title("F(t) - fuel")
	ax[2].set_title("v(t) - velocity")
	#used fuel: fuel = self.consumption*dt*throttle
	#print(falconLander.fuel / Merlin1D().consumption) #how many seconds of full burn ~= 421.778
	try:
		#move(spacePositions, spaceObjects, dt, stepsCount)
		#moveThrust(spacePositions, spaceObjects, dt, thrustTab)
		moveFuel(spacePositions, spaceObjects, dt, thrustTab)
	except Exception as e:
		print(e)
		print(f"Final velocity: {spaceObjects[1].v}")
	#print(f"{len(spacePositions)}: {spaceObjects}\n\n")
	#spacePositions = {"positions": spacePositions,
	#				  "spaceObjects": [{"p": s.p, "v": s.v, "m": s.mass, "r": s.radius} for s in spaceObjects],
	#				  "timeDelta": dt,
	#				  "stepsCount": stepsCount}
	#with open('static/data.json', 'w') as myFile:
	#	json.dump(spacePositions, myFile)

	
	for i in range(len(spaceObjects)):
		x = []
		y = []
		f = []
		vv = []
		for sp in spacePositions:
			x.append(sp[i]['p'][0])
			y.append(sp[i]['p'][1])
			f.append(sp[i]['f'])
			vv.append(sp[i]['v'][1])
		#plt.plot(x, y)
	
	ax[2].set_ylim(min(vv), max(vv))
	anim = ani.FuncAnimation(fig, buildPlot, interval = 10)
	anim2 = ani.FuncAnimation(fig, buildPlot2, interval = 10)
	anim3 = ani.FuncAnimation(fig, buildPlot3, interval = 10)
	plt.show()

	"""
	t = list(range(6))
	for i in range(6):
		with open(f'best_score-per_gen_{i+1}.json') as f:
			data = json.load(f)
			t[i] =  []
			for j in range(len(data)):
				t[i].append(data[j]['score'])
	
	print(t)
	fig, ax = plt.subplots(1,2, figsize=(10,5))
	ax[0].plot(t[0], color='red', label = 'p == 1')
	ax[1].plot(t[1], color='black', label = 'p == 2')
	ax[0].plot(t[2], color='orange', label = 'p == 3')
	ax[1].plot(t[3], color='green', label = 'p == 4')
	ax[0].plot(t[4], color='blue', label = 'p == 5')
	ax[1].plot(t[5], color='violet', label = 'p == 6')
	ax[0].legend()
	ax[1].legend()
	plt.show()
	